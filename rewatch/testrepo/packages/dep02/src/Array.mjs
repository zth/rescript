// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_array from "@rescript/runtime/lib/es6/Js_array.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_SortArray from "@rescript/runtime/lib/es6/Belt_SortArray.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function includes(prim0, prim1) {
  return prim0.includes(prim1);
}

function head(t) {
  return Belt_Array.get(t, 0);
}

function take(t, n) {
  return Belt_Array.slice(t, 0, n);
}

function last(t) {
  return Belt_Array.get(t, t.length - 1 | 0);
}

function isEmpty(t) {
  return t.length === 0;
}

function isNotEmpty(t) {
  return t.length !== 0;
}

function append(t, v) {
  return Belt_Array.concat(t, [v]);
}

function prepend(t, v) {
  return Belt_Array.concat([v], t);
}

function mapi(prim0, prim1) {
  return prim0.map(prim1);
}

function flatten(t) {
  return Belt_Array.concatMany(Belt_Array.map(t, x => x));
}

function find(t, fn) {
  return Js_array.find(fn, t);
}

function findIndex(t, fn) {
  return Js_array.findIndex(fn, t);
}

function filter(prim0, prim1) {
  return prim0.filter(prim1);
}

function reject(t, fn) {
  return t.filter(el => !fn(el));
}

function sortBy(t, fn) {
  return Belt_SortArray.stableSortBy(t, (a, b) => {
    let match = fn(a, b);
    if (match === "greater_than") {
      return 1;
    } else if (match === "less_than") {
      return -1;
    } else {
      return 0;
    }
  });
}

function joinWith(prim0, prim1) {
  return prim0.join(prim1);
}

function join(__x) {
  return __x.join("");
}

let $$String = {
  joinWith: joinWith,
  join: join
};

function eqBy(_xs, _ys, fn) {
  while (true) {
    let ys = _ys;
    let xs = _xs;
    let match = Belt_Array.get(xs, 0);
    let match$1 = Belt_Array.get(ys, 0);
    if (match === undefined) {
      return match$1 === undefined;
    }
    if (match$1 === undefined) {
      return false;
    }
    if (!fn(Primitive_option.valFromOption(match), Primitive_option.valFromOption(match$1))) {
      return false;
    }
    _ys = Belt_Array.sliceToEnd(ys, 1);
    _xs = Belt_Array.sliceToEnd(xs, 1);
    continue;
  };
}

function takeWhile(t, fn) {
  let a = {
    contents: []
  };
  let maxLength = t.length - 1 | 0;
  let iter = _idx => {
    while (true) {
      let idx = _idx;
      if (idx >= maxLength) {
        return;
      }
      let item = t[idx];
      if (!fn(item)) {
        return;
      }
      a.contents = Belt_Array.concat(a.contents, [item]);
      _idx = idx + 1 | 0;
      continue;
    };
  };
  iter(0);
  return a.contents;
}

function distinct(t, eq) {
  let maxIdx = t.length;
  let _acc = [];
  let _idx = 0;
  while (true) {
    let idx = _idx;
    let acc = _acc;
    if (idx >= maxIdx) {
      return acc;
    }
    let y = t[idx];
    let acc$1 = Belt_Array.some(acc, x => eq(x, y)) ? acc : Belt_Array.concat(acc, [y]);
    _idx = idx + 1 | 0;
    _acc = acc$1;
    continue;
  };
}

function partition(t, fn) {
  let maxLength = t.length;
  let _a = [];
  let _b = [];
  let _idx = 0;
  while (true) {
    let idx = _idx;
    let b = _b;
    let a = _a;
    if (idx >= maxLength) {
      return [
        a,
        b
      ];
    }
    let item = t[idx];
    let idx$1 = idx + 1 | 0;
    if (fn(item)) {
      _idx = idx$1;
      _a = Belt_Array.concat(a, [item]);
      continue;
    }
    _idx = idx$1;
    _b = Belt_Array.concat(b, [item]);
    continue;
  };
}

function replaceAt(t, idx, item) {
  return Belt_Array.mapWithIndex(t, (idx$p, el) => {
    if (idx === idx$p) {
      return item;
    } else {
      return el;
    }
  });
}

function indexOfBy(t, fn, value) {
  let _idx = 0;
  while (true) {
    let idx = _idx;
    let value$p = Belt_Array.get(t, idx);
    if (value$p === undefined) {
      return;
    }
    if (fn(value, Primitive_option.valFromOption(value$p))) {
      return idx;
    }
    _idx = idx + 1 | 0;
    continue;
  };
}

function swapAt(t, i, j) {
  let match = Belt_Array.get(t, i);
  let match$1 = Belt_Array.get(t, j);
  if (match === undefined) {
    return t;
  }
  if (match$1 === undefined) {
    return t;
  }
  let b = Primitive_option.valFromOption(match$1);
  let a = Primitive_option.valFromOption(match);
  return Belt_Array.mapWithIndex(t, (k, x) => {
    if (i === k) {
      return b;
    } else if (j === k) {
      return a;
    } else {
      return x;
    }
  });
}

function splitAt(t, i) {
  if (i < 0 || i > t.length) {
    return;
  }
  let a = Belt_Array.slice(t, 0, i);
  let b = Belt_Array.sliceToEnd(t, i);
  return [
    a,
    b
  ];
}

function insertAt(t, idx, x) {
  let match = splitAt(t, idx);
  if (match !== undefined) {
    return Belt_Array.concat(match[0], Belt_Array.concat([x], match[1]));
  } else {
    return t;
  }
}

function flatMap(t, fn) {
  return Belt_Array.concatMany(Belt_Array.map(t, fn));
}

function removeAt(t, idx) {
  return Belt_Array.keepWithIndex(t, (param, i) => i !== idx);
}

function drop(t, i) {
  let l = t.length;
  let start = i < 0 ? 0 : (
      l < i ? l : i
    );
  return Belt_Array.sliceToEnd(t, start);
}

function unsafePop(prim) {
  return prim.pop();
}

function sum(xs) {
  return Belt_Array.reduce(xs, 0, (a, b) => a + b | 0);
}

let Int = {
  sum: sum
};

function sum$1(xs) {
  return Belt_Array.reduce(xs, 0, (a, b) => a + b);
}

let Float = {
  sum: sum$1
};

function clear(t) {
  t.length = 0;
}

let get = Belt_Array.get;

let getExn = Belt_Array.getExn;

let getOrThrow = Belt_Array.getOrThrow;

let set = Belt_Array.set;

let setExn = Belt_Array.setExn;

let setOrThrow = Belt_Array.setOrThrow;

let shuffleInPlace = Belt_Array.shuffleInPlace;

let shuffle = Belt_Array.shuffle;

let reverseInPlace = Belt_Array.reverseInPlace;

let reverse = Belt_Array.reverse;

let make = Belt_Array.make;

let range = Belt_Array.range;

let rangeBy = Belt_Array.rangeBy;

let makeByU = Belt_Array.makeByU;

let makeBy = Belt_Array.makeBy;

let makeByAndShuffleU = Belt_Array.makeByAndShuffleU;

let makeByAndShuffle = Belt_Array.makeByAndShuffle;

let zip = Belt_Array.zip;

let zipByU = Belt_Array.zipByU;

let zipBy = Belt_Array.zipBy;

let unzip = Belt_Array.unzip;

let concat = Belt_Array.concat;

let concatMany = Belt_Array.concatMany;

let slice = Belt_Array.slice;

let sliceToEnd = Belt_Array.sliceToEnd;

let fill = Belt_Array.fill;

let blit = Belt_Array.blit;

let blitUnsafe = Belt_Array.blitUnsafe;

let forEachU = Belt_Array.forEachU;

let forEach = Belt_Array.forEach;

let mapU = Belt_Array.mapU;

let map = Belt_Array.map;

let flatMapU = Belt_Array.flatMapU;

let getByU = Belt_Array.getByU;

let getBy = Belt_Array.getBy;

let getIndexByU = Belt_Array.getIndexByU;

let getIndexBy = Belt_Array.getIndexBy;

let keepU = Belt_Array.keepU;

let keep = Belt_Array.keep;

let keepWithIndexU = Belt_Array.keepWithIndexU;

let keepWithIndex = Belt_Array.keepWithIndex;

let keepMapU = Belt_Array.keepMapU;

let keepMap = Belt_Array.keepMap;

let forEachWithIndexU = Belt_Array.forEachWithIndexU;

let forEachWithIndex = Belt_Array.forEachWithIndex;

let mapWithIndexU = Belt_Array.mapWithIndexU;

let mapWithIndex = Belt_Array.mapWithIndex;

let partitionU = Belt_Array.partitionU;

let reduceU = Belt_Array.reduceU;

let reduce = Belt_Array.reduce;

let reduceReverseU = Belt_Array.reduceReverseU;

let reduceReverse = Belt_Array.reduceReverse;

let reduceReverse2U = Belt_Array.reduceReverse2U;

let reduceReverse2 = Belt_Array.reduceReverse2;

let reduceWithIndexU = Belt_Array.reduceWithIndexU;

let reduceWithIndex = Belt_Array.reduceWithIndex;

let joinWithU = Belt_Array.joinWithU;

let joinWith$1 = Belt_Array.joinWith;

let someU = Belt_Array.someU;

let some = Belt_Array.some;

let everyU = Belt_Array.everyU;

let every = Belt_Array.every;

let every2U = Belt_Array.every2U;

let every2 = Belt_Array.every2;

let some2U = Belt_Array.some2U;

let some2 = Belt_Array.some2;

let cmpU = Belt_Array.cmpU;

let cmp = Belt_Array.cmp;

let eqU = Belt_Array.eqU;

let eq = Belt_Array.eq;

let initU = Belt_Array.initU;

let init = Belt_Array.init;

let at = Belt_Array.get;

let sortByRaw = Belt_SortArray.stableSortBy;

export {
  get,
  getExn,
  getOrThrow,
  set,
  setExn,
  setOrThrow,
  shuffleInPlace,
  shuffle,
  reverseInPlace,
  reverse,
  make,
  range,
  rangeBy,
  makeByU,
  makeBy,
  makeByAndShuffleU,
  makeByAndShuffle,
  zip,
  zipByU,
  zipBy,
  unzip,
  concat,
  concatMany,
  slice,
  sliceToEnd,
  fill,
  blit,
  blitUnsafe,
  forEachU,
  forEach,
  mapU,
  map,
  flatMapU,
  getByU,
  getBy,
  getIndexByU,
  getIndexBy,
  keepU,
  keep,
  keepWithIndexU,
  keepWithIndex,
  keepMapU,
  keepMap,
  forEachWithIndexU,
  forEachWithIndex,
  mapWithIndexU,
  mapWithIndex,
  partitionU,
  reduceU,
  reduce,
  reduceReverseU,
  reduceReverse,
  reduceReverse2U,
  reduceReverse2,
  reduceWithIndexU,
  reduceWithIndex,
  joinWithU,
  joinWith$1 as joinWith,
  someU,
  some,
  everyU,
  every,
  every2U,
  every2,
  some2U,
  some2,
  cmpU,
  cmp,
  eqU,
  eq,
  initU,
  init,
  at,
  includes,
  head,
  take,
  last,
  isEmpty,
  isNotEmpty,
  append,
  prepend,
  mapi,
  flatten,
  find,
  findIndex,
  filter,
  reject,
  sortBy,
  sortByRaw,
  $$String,
  eqBy,
  takeWhile,
  distinct,
  partition,
  replaceAt,
  indexOfBy,
  swapAt,
  splitAt,
  insertAt,
  flatMap,
  removeAt,
  drop,
  unsafePop,
  Int,
  Float,
  clear,
}
/* No side effect */
